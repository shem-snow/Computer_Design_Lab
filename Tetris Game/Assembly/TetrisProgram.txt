#Tetris Program

.start
movi $0 r0
movi $0 r1
movi $0 r2
movi $0 r3
movi $0 r4
movi $0 r5
movi $0 r6
movi $0 r7
movi $0 r8
movi $0 r9
movi $0 r10
movi $0 r11
movi $0 r12
movi $0 r13
movi $0 r14
movi $0 r15
movi $0 r16
.clearBitMap
MOVW 1024 r5
cmp r5 r9
beq .checkInput
MOVW 1003 r9
stor r0 r9
addi $1 r9
buc .clearBitMap

.checkInput
MOVW 1023 r9
load r10 r9
cmpi $0 r10
beq .checkInput

.createNewPiece
#check for death 
MOVW 1023 r10
load r11 r10 #r11 top line 
subi $1 r10
load r12 r10 #r12 second from top line 
andi $48 r11
cmpi $16 r11 #anything greater than 16 means pieces there already
bge .start #death 
andi $48 r12
cmpi $16 r12
bge .start

#reset register pointers 
movi $5 r1
movi $20 r2
mov r3 r4
andi $12 r4

#determine what block next 
cmpi $0 r4
beq .spawnLeftL
cmpi $1 r4 
beq .spawnRightL
buc .spawnBlock

.spawnLeftL
ori $32 r11
ori $48 r12
MOVW 1022 r10
stor r12 r10
addi $1 r10
stor r11 r10
buc .gameLoop #TO DO: change to actual thing

.spawnRightL
ori $32 r11
ori $48 r12
MOVW 1022 r10
stor r12 r10
addi $1 r10
stor r11 r10
buc .gameLoop #TO DO: change to actual thing

.spawnBlock
ori $16 r11
ori $48 r12
MOVW 1022 r10
stor r12 r10
addi $1 r10
stor r11 r10
buc .gameLoop #TO DO: change to actual thing

########################################################
#Check collision and line check
#collide?
#no -> fall and done
#yes -> full line?

#full line?
#no -> restart
#yes -> remove line and fall then restart

#First Need to check collision
.checkCollision
MOV r1 r4   #r4 is the current horizontal of piece
MOVW 1002 r5 #current bottom piece location
ADD r2 r5   #r5 is the current vertical of piece


#Two lines needed from map
LOAD r5 r8 #top line in map
SUBI $1 r5
LOAD r5 r9 #next line down

#Piece type and Orientation
MOV r3 r6    
ANDI $12 r6   #r6 = current shape
MOV r3 r7   
ANDI $3 r7   #r7 = orientation

# R6 -- 0 = block, 1 = L, 2 = I
# R7 -- Permutation.
#Use Piece, orientation, and Horizontal to get Piece (get piece/orientation then shift)

#GET TO COMP. of block type
cmpi $0 r6
beq .block 
cmpi $4 r6
beq .el
buc .line

#determine block
.block 
movi $3 r10
movi $3 r11
LSH r4 r10
LSH r4 r11 #two sets of shifted mask
AND r8 r10
AND r9 r11 #if r10 or r11 are not zero then collision
cmpi $0 r11
bne .collision
cmpi $0 r10
bne .collision #if either are not zero then go collide 
buc .fall #else go to fall.

#determine EL 
.el
cmpi $0 r7
beq .jEl0 
cmpi $1 r7
beq .jEl1
cmpi $2 r7
beq .jEl2
buc .jEl3

#case 1 perm 0 
.jEl0
movi $2 r10
movi $3 r11
LSH r4 r10
LSH r4 r11 #two sets of shifted mask
AND r8 r10
AND r9 r11 #if r10 or r11 are not zero then collision
cmpi $0 r11
bne .collision
cmpi $0, r10
bne .collision #if either are not zero then go collide 
buc .fall #else go to fall.

#case 2 perm 1
.jEl1
movi $3 r10
movi $2 r11
LSH r4 r10
LSH r4 r11 #two sets of shifted mask
AND r8 r10
AND r9 r11 #if r10 or r11 are not zero then collision
cmpi $0 r11
bne .collision
cmpi $0, r10
bne .collision #if either are not zero then go collide 
buc .fall #else go to fall.

#case 3 perm 2
.jEl2
movi $3 r10
movi $1 r11
LSH r4 r10
LSH r4 r11 #two sets of shifted mask
AND r8 r10
AND r9 r11 #if r10 or r11 are not zero then collision
cmpi $0 r11
bne .collision
cmpi $0, r10
bne .collision #if either are not zero then go collide 
buc .fall #else go to fall.

#case 4 perm 3
.jEl3
movi $1 r10
movi $3 r11
LSH r4 r10
LSH r4 r11 #two sets of shifted mask
AND r8 r10
AND r9 r11 #if r10 or r11 are not zero then collision
cmpi $0 r11
bne .collision
cmpi $0, r10
bne .collision #if either are not zero then go collide 
buc .fall #else go to fall.

#determine Line 
.line
cmpi $0 r7
beq .jline0 
cmpi $1 r7
beq .jline1
cmpi $2 r7
beq .jline2
buc .jline3

#case 1 perm 0 
.jline0
movi $2 r10
movi $2 r11
LSH r4 r10
LSH r4 r11 #two sets of shifted mask
AND r8 r10
AND r9 r11 #if r10 or r11 are not zero then collision
cmpi $0 r11
bne .collision
cmpi $0, r10
bne .collision #if either are not zero then go collide 
buc .fall #else go to fall.

#case 2 perm 1
.jline1
movi $3 r10
movi $0 r11
LSH r4 r10
LSH r4 r11 #two sets of shifted mask
AND r8 r10
AND r9 r11 #if r10 or r11 are not zero then collision
cmpi $0 r11
bne .collision
cmpi $0, r10
bne .collision #if either are not zero then go collide 
buc .fall #else go to fall.

#case 3 perm 2
.jline2
movi $1 r10
movi $1 r11
LSH r4 r10
LSH r4 r11 #two sets of shifted mask
AND r8 r10
AND r9 r11 #if r10 or r11 are not zero then collision
cmpi $0 r11
bne .collision
cmpi $0, r10
bne .collision #if either are not zero then go collide 
buc .fall #else go to fall.

#case 4 perm 3
.jline3
movi $0 r10
movi $3 r11
LSH r4 r10
LSH r4 r11 #two sets of shifted mask
AND r8 r10
AND r9 r11 #if r10 or r11 are not zero then collision
cmpi $0 r11
bne .collision
cmpi $0, r10
bne .collision #if either are not zero then go collide 
buc .fall #else go to fall.

#Check if collide with AND or at bottom then see if it is equal to zero for both jump to either fall or line check
.collision
MOVW 1002 r5 #current bottom piece location
ADD r2 r5   #r5 reset r5

#Two lines needed from map of piece
LOAD r5 r8 #top line in map
ADDI $1 r5
LOAD r5 r9 #next line down
SUBI $1 r5

MOVW 65535 r13
xor r13 r8
xor r13 r9

movi $0 r13
or r8 r13
or r9 r13
cmpi $0 r13
mov r5 r12      #r12 shows which line was empty
beq .cleartwo   #if they are both zero then clear both
cmpi $0 r8       
beq .clearline   #if not zero then not full
cmpi $0 r9 
ADDI $1 r12
beq .clearline      #if not zero then not full
buc .gameLoop

#Line Check (store current piece then check both the top line and next line as used before)
.clearline #if i am here i have the line to start at in r12 and just need to replace until top 
mov r12 r13
addi $1 r13
load r13 r14
store r14 r12
addi $1 r12
MOVW 1022 r10
cmp r10 r12 #if it leaves the board then be done clearing
beq .gameLoop
buc .clearline

#two lines were cleared so move everything down two.
.cleartwo
mov r12 r13
addi $2 r13
load r13 r14
store r14 r12
addi $1 r12
MOVW 1021 r10
cmp r10 r12 #if it leaves the board then be done clearing
beq .gameLoop
buc .cleartwo


########################################
